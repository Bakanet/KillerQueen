C'etait marrant les labyrinthes. Le TP etait vraiment pas complique, fallait surtout aller chercher les trucs sur MSDN quoi.
Bonus faits : l'affichage (fonction PrintMaze).
La fonction ResolveMaze dans le Main permet d'appeler toutes les fonctions avec en plus l'affichage avant et apres la resolution du labyrinthe.

Deuxieme bonus : c'est parti pour tenter un A* (avec un peu d'aide de Justin).
On cree une classe Node qui permet de stocker les coords d'un noeud, ainsi que son poids (utile pour choisir le chemin le plus rapide), et sa "direction" qui designe
en realite son predecesseur (le noeud duquel on vient).
La methode ComputeValue sert a calculer la distance entre le noeud actuel et l'arrivee de notre labyrinthe.
Notre fonction FindFinish est... un c/c du FindStart.
La GetNeighboursValue a pour but de calculer le poids des 4 noeuds autour de notre point (sauf s'il est en dehors de la grid, si c'est un block, ou si on l'a deja explore).
Notre list toExplore permet de verifier quels noeuds on doit encore explorer.
GottaGoFast (sonic.exe reference) sert a recuperer le noeud avec le poids le moins lourd (donc le chemin le plus rapide), l'ajouter dans la liste des noeuds explores et le retirer
de ceux qu'il nous reste a explorer.
Fonction PathFinding : on définit un point start et finish, ainsi que nos fameuses listes toExplore et doneNodes. La première while boucle tant qu'il reste
des noeuds dans notre liste à explorer et qu'on n'a pas atteint l'arrivée.
Si notre liste à explorer est vide, c'est qu'on a testé toutes les possibilités et qu'il est impossible de finir le labyrinthe. Sinon on entre dans une dernière boucle
qui va parcourir notre chemin en sens inverse en mettant des P à chaque fois qu'on passe par une case du chemin.

Sinon une idee pour le prochain TP avec des labyrinthes : https://youtu.be/x9hBWnh_O6A

g pa dumour du kou g pa de blag :(